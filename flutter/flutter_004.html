<hr>
<p>title: Flutter 當我們黏在一起：Provider<br>date: 2019-05-14<br>categories: Flutter<br>keywords:</p>
<ul>
<li>Flutter</li>
<li>Dart<br>tags:</li>
<li>Flutter</li>
<li>Dart</li>
</ul>
<hr>
<p><img src="/images/flutter/004/flutter_000.png" alt="img">  </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>依賴注入(Dependency Injection)</strong> 可以說是降低程式耦合度最簡單的方法，我們預先將某種”資源”注入到程式內，然後可以在任何地方自由提起該”資源”，完全不必理會這個資源在哪建立又放置在哪，我們只要知道有某種機制可以在我們需要時幫我們提取我們所需要的東西，接下來我們就嘗試如何在 Flutter 上做到該效果。  </p>
<!-- more -->  

<h1 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h1><p>Flutter 提供一個有趣的 Widget - <strong>InheritedWidget</strong> 來協助我們傳遞資訊，我們可以看到<a href="https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html">官網的範例</a>如下：<br><img src="/images/flutter/004/flutter_001.png" alt="img"><br><code>child</code> 表示原本要呈現的 <strong>Widget</strong>，<code>color</code> 表示要添加的<strong>資源</strong>，<code>updateShouldNotify</code> 方法主要是判斷是否要做變更通知，這邊主要是判斷所添加的<strong>資源</strong>是否有變化，簡單的說就是<strong>再利用一個 Widget 將原本的 Widget 與想要增加的額外資源綁在一起</strong>，這樣做跟直接將<strong>資源</strong>加到既有的 Widget 上有什麼差別呢？<br>在 <strong>BuildContext</strong> 提供了一個方法 <code>inheritFromWidgetOfExactType</code> 可以協助我們由目前的 Widget 所在的 Widget Tree 位置往上尋找第一個符合資源型態的資源，習慣上我們也會直接建立一個靜態的 <code>of</code> 方法來協助我們搜尋，這表示如果上層 Widget 已經有提供資源，我們可以直接利用 <code>of</code> 方法來抓取，不須重新建立，當然如果將資源綁在最上層(Root Widget)，這個資源就會變成一個全域性的資源，在這個 App 上的任何 Widget 都可以存取到。  </p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>接下來我們建立一個範例來說明，首先建立一個名為 <strong>IWidget</strong> 的 InheritedWidget，並宣告一個字串型別的 <code>value</code> 屬性來模擬額外添加的資源，程式碼如下：  </p>
<p>{% codeblock main.dart lang:dart %}<br>class IWidget extends InheritedWidget {<br>  final String value;<br>  IWidget({@required this.value, Widget child}) : super(child: child);</p>
<p>  static IWidget of(BuildContext context) {<br>    return context.inheritFromWidgetOfExactType(IWidget);<br>  }</p>
<p>  @override<br>  bool updateShouldNotify(IWidget old) {<br>    return old.value != value;<br>  }<br>}<br>{% endcodeblock %}  </p>
<p>接著我們再增加一個名為 <strong>ValueWidget</strong> 的 StatelessWidget，他會去抓取 <strong>IWidget</strong> 的 <code>value</code> 屬性並透過 <strong>Text</strong> 呈現出來，在這邊我們增加 color 屬性<br>，藉以改變 Widget 的背景顏色，方便我們可以區分每個 Widget，並添加一個 <code>child</code> 屬性讓我們可以在 <strong>ValueWidget</strong> 裡面在放置其他 Widget，藉以模擬 Widget Tree 的階層特性，程式碼如下：  </p>
<p>{% codeblock main.dart lang:dart %}<br>class ValueWidget extends StatelessWidget {<br>  final Widget child;<br>  final Color color;<br>  ValueWidget({Key key, this.color = Colors.white, this.child}) : super(key: key);</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    return Container(<br>      padding: EdgeInsets.all(8),<br>      color: color,<br>      child: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: <Widget>[<br>            if (IWidget.of(context) != null)<br>              Text(‘value：${IWidget.of(context).value}’)<br>            else<br>              Text(<br>                ‘value：null’,<br>              ),<br>            if (child != null) child,<br>          ],<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<blockquote>
<p><a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md">Dart 2.2.2</a> 版增加 <strong>Collection if</strong> 與 <strong>Collection for</strong>，讓我們可以在集合物件內使用 <code>if</code> 與 <code>for</code>，要使用的話需修改 <code>pubspec.yaml</code> 內 SDK 的最低版本。<br><img src="/images/flutter/004/flutter_003.png" alt="img"><br><img src="/images/flutter/004/flutter_004.png" alt="img">  </p>
</blockquote>
<p>接著我們建構一個 <strong>MyHomePage</strong> 的 Widget，在最外層放置一個 <strong>IWidget</strong>，並在裡面堆疊4層 <strong>ValueWidget</strong>，程式碼如下：  </p>
<p>{% codeblock main.dart lang:dart %}<br>class MyHomePage extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      body: IWidget(<br>        value: ‘AAA’,<br>        child: ValueWidget(<br>          color: Colors.grey,<br>          child: ValueWidget(<br>            color: Colors.orange,<br>            child: ValueWidget(<br>              color: Colors.blue,<br>              child: ValueWidget(<br>                color: Colors.green,<br>              ),<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}  </p>
<p>最後再將 <strong>MyHomePage</strong> 添加到專案預設的專案預設的 <strong>MyApp</strong> 內，完整程式如下：<br>{% codeblock main.dart lang:dart %}<br>import ‘package:flutter/material.dart’;</p>
<p>void main() =&gt; runApp(MyApp());</p>
<p>class MyApp extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return MaterialApp(<br>      title: ‘Flutter Demo’,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>        textTheme: TextTheme(<br>          body1: TextStyle(fontSize: 30),<br>        ),<br>      ),<br>      home: MyHomePage(),<br>    );<br>  }<br>}</p>
<p>class MyHomePage extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      body: IWidget(<br>        value: ‘AAA’,<br>        child: ValueWidget(<br>          color: Colors.grey,<br>          child: ValueWidget(<br>            color: Colors.orange,<br>            child: ValueWidget(<br>              color: Colors.blue,<br>              child: ValueWidget(<br>                color: Colors.green,<br>              ),<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}</p>
<p>class IWidget extends InheritedWidget {<br>  final String value;<br>  IWidget({@required this.value, Widget child}) : super(child: child);</p>
<p>  static IWidget of(BuildContext context) {<br>    return context.inheritFromWidgetOfExactType(IWidget);<br>  }</p>
<p>  @override<br>  bool updateShouldNotify(IWidget old) {<br>    return old.value != value;<br>  }<br>}</p>
<p>class ValueWidget extends StatelessWidget {<br>  final Widget child;<br>  final Color color;<br>  ValueWidget({Key key, this.color = Colors.white, this.child}) : super(key: key);</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    return Container(<br>      padding: EdgeInsets.all(8),<br>      color: color,<br>      child: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: <Widget>[<br>            if (IWidget.of(context) != null)<br>              Text(‘value：${IWidget.of(context).value}’)<br>            else<br>              Text(<br>                ‘value：null’,<br>              ),<br>            if (child != null) child,<br>          ],<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<p>執行專案可以看到如下的效果，不管哪一層的 <strong>ValueWidget</strong> 都可以輕鬆地透過 <code>IWidget.of(context).value</code> 來讀取到 <strong>IWidget</strong> 的 <code>value</code>。<br><img src="/images/flutter/004/flutter_002.png" alt="img"><br>接著我們在第2層 <strong>ValueWidget</strong> 內先插入一個 <strong>IWidget</strong>，並設定 <code>value:BBB</code>。<br>{% codeblock main.dart lang:dart %}<br>class MyHomePage extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      body: IWidget(<br>        value: ‘AAA’,<br>        child: ValueWidget(<br>          color: Colors.grey,<br>          child: ValueWidget(<br>            color: Colors.orange,<br>            child: IWidget(<br>              value: ‘BBB’,<br>              child: ValueWidget(<br>                color: Colors.blue,<br>                child: ValueWidget(<br>                  color: Colors.green,<br>                ),<br>              ),<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<p>儲存後透過 Flutter <strong>hot reload</strong> 機制可以馬上看到變化，由呈現的 <code>value</code> 可以知道所有的 <strong>ValueWidget</strong> 都會抓到離自己最近的 <strong>IWidget</strong>。<br><img src="/images/flutter/004/flutter_005.png" alt="img"><br>接下來我們把最外層的 <strong>IWidget</strong> 拿掉。<br>{% codeblock main.dart lang:dart %}<br>class MyHomePage extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      body: ValueWidget(<br>        color: Colors.grey,<br>        child: ValueWidget(<br>          color: Colors.orange,<br>          child: IWidget(<br>            value: ‘BBB’,<br>            child: ValueWidget(<br>              color: Colors.blue,<br>              child: ValueWidget(<br>                color: Colors.green,<br>              ),<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<p>我們可以看到最外2層的 <strong>ValueWidget</strong> 因為搜尋不到 <strong>IWidget</strong>，所以顯示為 <code>null</code>。<br><img src="/images/flutter/004/flutter_006.png" alt="img">  </p>
<h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><p>今年的 Google I/O 也提到 Flutter 的狀態管理議題 - <a href="https://www.youtube.com/watch?v=d_m5csmrf7I&feature=youtu.be">Pragmatic State Management in Flutter (Google I/O’19)</a>，有別於以往今年多介紹另一個 Package - **<a href="https://pub.dev/packages/provider">Provider</a>**。<br>{% blockquote pub.dev： <a href="https://pub.dev/packages/provider">https://pub.dev/packages/provider</a> Provider %}<br>A dependency injection system built with widgets for widgets. provider is mostly syntax sugar for InheritedWidget, to make common use-cases straightforward.<br>{% endblockquote %}</p>
<p>從說明頁面可以看到 <strong>Provider</strong> 提供了依賴注入(Dependency Injection)的功能，當然也直接講明他就是 <strong>InheritedWidget</strong> 語法糖，連到 GitHub 去看<a href="https://github.com/rrousselGit/provider/blob/master/lib/src/provider.dart">provider.dart</a> 核心的原始碼，可以知道它確實繼承自 <strong>InheritedWidget</strong>，特別的是它提供泛型的宣告來指定所要添加的資源，並將資源的變數強制訂為 <code>value</code>，所以相同的我們可以透過 <code>of</code> 方法來取的 <code>value</code> 的資料。<br>{% codeblock provider.dart lang:dart %}<br>class _Provider<T> extends InheritedWidget {<br>  const _Provider({<br>    Key key,<br>    @required this.value,<br>    UpdateShouldNotify<T> updateShouldNotify,<br>    Widget child,<br>  })  : _updateShouldNotify = updateShouldNotify,<br>        super(key: key, child: child);</p>
<p>  final T value;<br>  final UpdateShouldNotify<T> _updateShouldNotify;</p>
<p>  @override<br>  bool updateShouldNotify(_Provider<T> oldWidget) {<br>    if (_updateShouldNotify != null) {<br>      return _updateShouldNotify(oldWidget.value, value);<br>    }<br>    return oldWidget.value != value;<br>  }<br>}<br>{% endcodeblock %}</p>
<h2 id="範例一"><a href="#範例一" class="headerlink" title="範例一"></a>範例一</h2><p>接下來我們將原本的範例修改為 <strong>Provider</strong> 版本，首先在 <code>pubspec.yaml</code> 內引用 provider。<br><img src="/images/flutter/004/flutter_007.png" alt="img">  </p>
<blockquote>
<p>在 VS Code 內儲存時會自動幫我們執行<code>flutter package get</code> 指令，幫我們下載 package。</p>
</blockquote>
<p>接著將 <strong>MyHomePage</strong> 內的 <code>IWidget</code> 修改為 <code>Provider.value</code>。<br>{% codeblock main.dart lang:dart %}<br>import ‘package:provider/provider.dart’;</p>
<p>class MyHomePage extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      body: Provider.value(<br>        value: ‘AAA’,<br>        child: ValueWidget(<br>          color: Colors.grey,<br>          child: ValueWidget(<br>            color: Colors.orange,<br>            child: Provider.value(<br>              value: ‘BBB’,<br>              child: ValueWidget(<br>                color: Colors.blue,<br>                child: ValueWidget(<br>                  color: Colors.green,<br>                ),<br>              ),<br>            ),<br>          ),<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<p>在 <strong>ValueWidget</strong> 內將讀取方式由 <code>IWidget.of</code> 改為 <code>Provider.of&lt;String&gt;</code>。<br>{% codeblock main.dart lang:dart %}<br>class ValueWidget extends StatelessWidget {<br>  final Widget child;<br>  final Color color;<br>  ValueWidget({Key key, this.color = Colors.white, this.child}) : super(key: key);</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    return Container(<br>      padding: EdgeInsets.all(8),<br>      color: color,<br>      child: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: <Widget>[<br>            if (Provider.of<String>(context) != null)<br>              Text(‘value：${Provider.of<String>(context)}’)<br>            else<br>              Text(<br>                ‘value：null’,<br>              ),<br>            if (child != null) child,<br>          ],<br>        ),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<p>重新執行專案可以看到一樣的效果，只是 <strong>IWidget</strong> 被 <strong>Provider</strong> 替換掉了，也就是說其實 <strong>Provider</strong> 幫我們撰寫好 <strong>InheritedWidget</strong> 的部分。<br><img src="/images/flutter/004/flutter_008.png" alt="img">  </p>
<h2 id="範例二：StreamProvider"><a href="#範例二：StreamProvider" class="headerlink" title="範例二：StreamProvider"></a>範例二：StreamProvider</h2><p>在上一篇文章 <a href="/flutter/flutter_004/">Dart 敗部復活賽：Flutter for Web</a> 我們用 <a href="https://pub.dev/packages/rxdart">RxDart</a> 這個 package 來做到跨 Widget 的同步通知，現在我們將它替換成 StreamController 來處理，並透過 Provider 的 Stream 版本 <strong><a href="https://pub.dev/documentation/provider/latest/provider/StreamProvider-class.html">StreamProvider</a></strong> 來注入 StreamController。<br>首先在 <code>pubspec.yaml</code> 內引用 provider。<br><img src="/images/flutter/004/flutter_009.png" alt="img"><br>接著在 <code>lib\rd.dart</code> 內 將全域變數的 <code>BehaviorSubject&lt;bool&gt;</code> 替換為 <code>StreamController&lt;bool&gt;</code>，並移除 Widget 內的 <code>StreamSubscription</code> 變數與 <code>initState</code>、<code>dispose</code> 方法，因為我們不需要在<strong>訂閱通知</strong>與<strong>取消訂閱通知</strong>。<br><img src="/images/flutter/004/flutter_010.png" alt="img"><br>接著我們在需要取值得地方一樣透過 <code>Provider.of</code> 來讀取資料。<br><img src="/images/flutter/004/flutter_011.png" alt="img"><br>接著將修改值的方法由 <code>subject.add</code> 替換為 <code>controller.add</code>。<br><img src="/images/flutter/004/flutter_013.png" alt="img"><br>因為我們必須要在目前 Widget 之前(上一層)先注入才有辦法讀取到資料，所以我們直接在 <strong>MyApp</strong> 內的 <strong>RxPage</strong> 外邊包一層 <strong>StreamProvider</strong>。<br><img src="/images/flutter/004/flutter_012.png" alt="img"><br>完整程式碼如下：<br>{% codeblock main.dart lang:dart %}<br>import ‘dart:async’;<br>import ‘package:flutter/material.dart’;<br>import ‘package:provider/provider.dart’;</p>
<p>final controller = StreamController<bool>();</p>
<p>void main() =&gt; runApp(MyApp());</p>
<p>class MyApp extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return MaterialApp(<br>      title: ‘Flutter Demo’,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      home: StreamProvider.value(<br>        initialData: false,<br>        stream: controller.stream,<br>        child: RxPage(),<br>      ),<br>    );<br>  }<br>}</p>
<p>class RxPage extends StatefulWidget {<br>  @override<br>  _RxPageState createState() =&gt; _RxPageState();<br>}</p>
<p>class _RxPageState extends State<RxPage> {</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    List<Widget> list = <Widget>[];<br>    bool isLogin = Provider.of<bool>(context);<br>    if (isLogin) {<br>      list.add(UserAccountsDrawerHeader(<br>        accountEmail: Text(“<a href="mailto:&#106;&#x6f;&#110;&#110;&#121;&#104;&#x75;&#97;&#x6e;&#103;&#64;&#x6f;&#x75;&#x74;&#x6c;&#111;&#x6f;&#106;&#46;&#x63;&#111;&#109;">&#106;&#x6f;&#110;&#110;&#121;&#104;&#x75;&#97;&#x6e;&#103;&#64;&#x6f;&#x75;&#x74;&#x6c;&#111;&#x6f;&#106;&#46;&#x63;&#111;&#109;</a>“),<br>        accountName: Text(“Jonny”),<br>        currentAccountPicture: CircleAvatar(<br>          child: Text(“J”),<br>        ),<br>      ));<br>    } else {<br>      list.add(DrawerHeader(<br>        decoration: BoxDecoration(<br>          color: Colors.orange,<br>        ),<br>        child: Text(“Guest”),<br>      ));<br>    }<br>    list.add(ListTile(<br>      title: Text(isLogin ? “登出” : “登入”),<br>      trailing: Icon(Icons.exit_to_app),<br>      onTap: () {<br>        controller.add(!isLogin);<br>      },<br>    ));</p>
<pre><code>return Scaffold(
  appBar: AppBar(
    title: Text(&#39;RxDart&#39;),
  ),
  drawer: Drawer(
    child: ListView(
      children: list,
    ),
  ),
  body: Page1Page(),
);
</code></pre>
<p>  }<br>}</p>
<p>class Page1Page extends StatefulWidget {<br>  @override<br>  _Page1PageState createState() =&gt; _Page1PageState();<br>}</p>
<p>class _Page1PageState extends State<Page1Page> {</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    bool isLogin = Provider.of<bool>(context);<br>    return Scaffold(<br>      body: Container(<br>        color: isLogin ? Colors.green : Colors.grey,<br>        alignment: Alignment.center,<br>        child: MaterialButton(<br>          child: Text(isLogin ? “登出” : “登入”),<br>          onPressed: () {<br>            controller.add(!isLogin);<br>          },<br>        ),<br>      ),<br>    );<br>  }<br>}</p>
<p>{% endcodeblock %}</p>
<p>執行專案可以看到操作效果跟原來的一樣。<br><img src="/images/flutter/004/flutter_015.gif" alt="img">  </p>
<h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>就如同官方說明一樣 <strong>Provider 是 InheritedWidget 的語法糖</strong>，當你了解到 InheritedWidget 的特性時也會明白 Provider 如何做到依賴注入，所以它不是要改變我們的程式架構，相反的在我們既有的撰寫模式下套用它可以讓程式變得更簡潔。  </p>
<h2 id="MultiProvider"><a href="#MultiProvider" class="headerlink" title="MultiProvider"></a>MultiProvider</h2><p>就如同官網範例 <strong>MultiProvider</strong> 可以協助我們很方便的注入多個 Provider，但是每多註冊一個 Provider 就等於多一層 Widget，Widget 的成本很低，所以效能的差異是可以忽略的，不過如果利用 Dart DevTools 來看 Widget Tree 時應該就會有些抱怨，因為多了很多層，有時候我們可以將多個資源合併在一起來減少堆疊次數。<br><img src="/images/flutter/004/flutter_014.png" alt="img">  </p>
