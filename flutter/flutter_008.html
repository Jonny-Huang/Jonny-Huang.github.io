<hr>
<p>title: Flutter：由 TextField 來看 Widget 如何保留狀態<br>date: 2019-07-10<br>categories: Flutter<br>keywords:</p>
<ul>
<li>Flutter</li>
<li>Dart<br>tags:</li>
<li>Flutter</li>
<li>Dart</li>
</ul>
<hr>
<p><img src="/images/flutter/008/flutter_000.png" alt="img">  </p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Flutter 開發過程中，可以說大部分都環繞在 <strong>StatelessWidget</strong> 與 <strong>StatefulWidget</strong> 之間，<strong>無狀態</strong>的 StatelessWidget 主要是做一次性的建置(<code>build</code>)，Flutter 在建構這個 Widget 時會去呼叫 <strong>build</strong> 方法一次。<br><img src="/images/flutter/008/flutter_001.png" alt="img"><br>最常使用的文件顯示 Widget - <strong>Text</strong> 便是 StatelessWidget，所以它在繪製完文字內容之後便不能再修改。<br><img src="/images/flutter/008/flutter_002.png" alt="img"><br><strong>有狀態</strong>的 StatefulWidget 則是可以重複建置(<code>build</code>)，它將建置動作交由 State 來處理，State 這個類別還提供一個 <code>setState</code> 方法，透過這個方法可以驅使 Flutter 再次呼叫 State 的 <code>build</code> 方法來重新建置 Widget，因此我們可以在 State 內宣告類別層級的變數來<strong>儲存資料</strong>，當<code>build</code> 方法重新建立 Widget 時，再將資料回填到對應的屬性，藉此達到<strong>狀態保留</strong>的功能。<br><img src="/images/flutter/008/flutter_003.png" alt="img"><br>最常使用的文件編輯 Widget - <strong>TextField</strong> 便是 StatefulWidget，我們每多輸入一個文字它會重新建置一次，但是他可以保留之前的內容(狀態)並將新輸入的文字累加進去。<br><img src="/images/flutter/008/flutter_004.png" alt="img"><br>剛說到 <strong>Text</strong> 無法重新建置，所以當呈現的文字內容要變更時，一般都是透過外層的 <strong>StatelessWidget</strong> 直接重新建立，當然如果需要保留它的狀態也必須透過外部暫存。  </p>
<!-- more -->  

<h1 id="神奇的-TextField"><a href="#神奇的-TextField" class="headerlink" title="神奇的 TextField"></a>神奇的 TextField</h1><p>我們再進一步思考 State 的 <code>build</code> 方法會<strong>重新建置</strong> Widget，這意味著透過 <code>build</code> 方法所建立的 Widget 不論是 StatelessWidget 或是 StatefulWidget 都無法保留自己狀態，除非我們特別將狀態儲存起來。<br>所以我們從官網文件 <a href="https://flutter.dev/docs/cookbook/forms/text-field-changes">Handle changes to a text field</a> 可以看到，要保留 TextField 的狀態方法可以宣告一個變數來儲存，並在 TextField 的 <code>onChanged</code> 事件內將目前的內容儲存到變數內。</p>
<p>{% codeblock main.dart lang:dart %}<br>class _MyHomePageState extends State<MyHomePage> {<br>  String data = ‘’;</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    var input = TextField(<br>      onChanged: onChanged: (text) =&gt; data = text,<br>    );<br>    …<br>  }<br>{% endcodeblock %}</p>
<p>或者透過 <strong>TextEditingController</strong> 來儲存。<br>{% codeblock main.dart lang:dart %}<br>class _MyHomePageState extends State<MyHomePage> {<br>  final myController = TextEditingController();</p>
<p>  @override<br>  Widget build(BuildContext context) {<br>    var input = TextField(<br>      controller: myController,<br>    );<br>    …<br>  }<br>{% endcodeblock %}</p>
<p>沒仔細想可能不會發現有些奇怪的地方，我們直接在專案預設範例內加入一個 TextField，而且不要幫它儲存任何狀態，主要程式碼如下：<br>{% codeblock main.dart lang:dart %}<br>class _MyHomePageState extends State<MyHomePage> {<br>  int _counter = 0;<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: <Widget>[<br>            Text(‘$_counter’),<br>            TextField(),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; setState(() {<br>          _counter++;<br>        }),<br>        tooltip: ‘Increment’,<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  }<br>}<br>{% endcodeblock %}</p>
<p>因為 FloatingActionButton 在點擊時會呼叫 <code>setState</code> 方法，因此每次按它時就會執行 <code>build</code> 方法來重建 Widget，所以<strong>理論上</strong> TextField 內容會被清空，接下來我們直接執行測試看看。<br><img src="/images/flutter/008/flutter_005.gif" alt="img"><br>神奇的事情發生了，既使透過 <code>build</code> 重建 TextField，但是 TextField 的內容仍然被保留下來，看來 TextField 似乎是一個在規則外的特殊 Widget。  </p>
<h2 id="TextEditingController"><a href="#TextEditingController" class="headerlink" title="TextEditingController"></a>TextEditingController</h2><p><strong>TextEditingController</strong> 跟我們使用變數來儲存內容有什麼差別，從原始碼可以知道 TextEditingController 繼承自 ValueNotifier<TextEditingValue>，而 <strong>TextEditingValue</strong> 除了儲存文字內容(<code>text</code>)之外還會多儲存其他狀態。<br><img src="/images/flutter/008/flutter_006.png" alt="img"><br>接著我們來從 TextField 的原始碼可以看到如下圖的關係：<br><img src="/images/flutter/008/flutter_007.png" alt="img">  </p>
<ul>
<li>State 內含 <code>widget</code> 屬性可以得知自己是由哪一個 StatelessWidget 所實作出來的，當然也可以藉此取得 StatelessWidget 的屬性。  </li>
<li>_TextFieldState 也建立一個 TextEditingController 變數 <code>_controller</code>，以及一個 <code>_effectiveController</code> 屬性，這個屬性主要是回傳我們在建立 TextField 時給予的 <code>controller</code>，如果我們未給予值時則以 <code>_controller</code> 替代。  </li>
</ul>
<p>{% codeblock main.dart lang:dart %}<br>class _TextFieldState extends State<TextField> with AutomaticKeepAliveClientMixin {<br>  …<br>  @override<br>  void initState() {<br>    super.initState();<br>    if (widget.controller == null)<br>      _controller = TextEditingController();<br>  }</p>
<p>  @override<br>  void didUpdateWidget(TextField oldWidget) {<br>    super.didUpdateWidget(oldWidget);<br>    if (widget.controller == null &amp;&amp; oldWidget.controller != null)<br>      _controller = TextEditingController.fromValue(oldWidget.controller.value);<br>    else if (widget.controller != null &amp;&amp; oldWidget.controller == null)<br>      _controller = null;<br>    final bool isEnabled = widget.enabled ?? widget.decoration?.enabled ?? true;<br>    final bool wasEnabled = oldWidget.enabled ?? oldWidget.decoration?.enabled ?? true;<br>    if (wasEnabled &amp;&amp; !isEnabled) {<br>      _effectiveFocusNode.unfocus();<br>    }<br>    if (_effectiveFocusNode.hasFocus &amp;&amp; widget.readOnly != oldWidget.readOnly) {<br>      if(_effectiveController.selection.isCollapsed) {<br>        _showSelectionHandles = !widget.readOnly;<br>      }<br>    }<br>  }<br>  …<br>}<br>{% endcodeblock %}
  </p>
